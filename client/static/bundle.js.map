{
  "version": 3,
  "sources": ["../functions/get.ts", "../functions/set.ts", "../functions/emit.ts", "../functions/on.ts", "../functions/use-mutation.ts", "../functions/use-query.ts", "../functions/use-key.ts", "../functions/use-publication.ts", "../functions/use-subscription.ts", "../functions/use-topic.ts", "../functions/use-state.ts", "../functions/use-counter.ts", "../functions/use-frames.ts", "../main.ts"],
  "sourcesContent": ["import { JsonValue } from \"../../shared\";\n\n/**\n * Retrieves a value associated with a given key through an asynchronous HTTP GET request.\n *\n * Utilizing the Fetch API, this function obtains the associated value from the '/key' endpoint. It raises an exception in the event of request failure or when both the retrieved value is undefined and no fallback value is provided.\n *\n * @typeParam T - Denotes the type of value anticipated from the request. This extends from `JsonValue | undefined`, implying it could be any JSON serializable data or undefined.\n * @param key - The key linked to the desired value. This should be a string representation.\n * @param initialValue - A fallback value that's returned when the fetched value is undefined. This can be any data type that extends `JsonValue | undefined`.\n * @returns A Promise that, when resolved, yields the fetched value. If this value is undefined, it defaults to the initialValue.\n *\n * @example\n * const value = await get('testKey', { key: 'value' });\n * // Attempts to retrieve the value linked to 'testKey'. If not found or undefined, it defaults to the provided object { key: 'value' }.\n *\n * @throws Error Raises an exception if:\n *         - The fetch request's response isn't satisfactory.\n *         - Both the retrieved value and the initialValue are undefined.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Fetch API\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n */\nexport const get = async <T extends JsonValue | undefined>(\n\tkey: string,\n\tinitialValue?: T,\n): Promise<T> => {\n\tconst response = await fetch(`/key/${encodeURIComponent(key)}`);\n\n\tlet value: T;\n\n\tif (response.ok) {\n\t\tvalue = JSON.parse(await response.json()) as T;\n\t} else {\n\t\tif (response.status === 404) {\n\t\t\tvalue = initialValue;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Failed to fetch value for key '${key}'. Response status: ${response.status}.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tif (value === undefined) {\n\t\tif (initialValue === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`Either ensure the desired value is set or furnish an initial value.`,\n\t\t\t);\n\t\t}\n\n\t\treturn initialValue;\n\t}\n\n\treturn value;\n};\n", "import { JsonValue } from \"../../shared\";\n\n/**\n * Asynchronously sets a value associated with a specified key using a HTTP POST request.\n *\n * The function uses the fetch API to send the value to the '/key' endpoint. It throws an error if the request fails.\n *\n * @typeParam T - The type of the value to be set. It extends from `JsonValue`, which means it can be any JSON serializable value.\n * @param key - The key with which the value should be associated. It should be a string.\n * @param value - The value to be set. It can be of any type that extends from `JsonValue`.\n * @returns A Promise that resolves to void. It does not return any value upon successful execution. If the HTTP request fails, it throws an error with the HTTP status text.\n *\n * @example\n * await set('testKey', { key: 'value' }); // Sets the object { key: 'value' } associated with the 'testKey'.\n *\n * @throws Error Will throw an error if the response status from the fetch request is not ok.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Fetch API\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n */\nexport const set = async <T extends JsonValue>(\n\tkey: string,\n\tvalue: T,\n): Promise<void> => {\n\tconst response = await fetch(`/key/${encodeURIComponent(key)}`, {\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t\tbody: JSON.stringify(value),\n\t});\n\n\tif (!response.ok) {\n\t\tthrow new Error(response.statusText);\n\t}\n};\n", "import { JsonValue } from \"../../shared\";\n\n/**\n * Asynchronously emits a message to a specified topic using a HTTP POST request.\n *\n * The function uses the fetch API to send the message to the '/topic' endpoint. It throws an error if the request fails.\n *\n * @typeParam T - The type of the data to be sent with the message. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param topic - The topic to which the message should be sent. It should be a string.\n * @param data - The data to be sent with the message. It can be of any type that extends from `JsonValue | undefined`.\n * @returns A Promise that resolves to void. It does not return any value upon successful execution. If the HTTP request fails, it throws an error with the HTTP status text.\n *\n * @example\n * await emit('testTopic', { key: 'value' }); // Sends the object { key: 'value' } to the 'testTopic' topic.\n *\n * @throws Error Will throw an error if the response status from the fetch request is not ok.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Fetch API\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n */\nexport const emit = async <T extends JsonValue | undefined>(\n\ttopic: string,\n\tdata?: T,\n): Promise<void> => {\n\tconst response = await fetch(`/topic/${encodeURIComponent(topic)}`, {\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t\tbody: JSON.stringify(data),\n\t});\n\n\tif (!response.ok) {\n\t\tthrow new Error(response.statusText);\n\t}\n};\n", "import { JsonValue } from \"../../shared\";\n\n/**\n * Sets up a listener for a specified topic using the EventSource API.\n *\n * The function opens a persistent connection to the '/topic' endpoint, and listens for messages on the specified topic.\n * It then parses the incoming data from the message event and passes it to a provided handler function.\n *\n * @typeParam T - The expected type of the data to be received with the message. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param topic - The topic to which the listener should be set up. It should be a string.\n * @param handler - The function that will handle incoming messages. It takes one argument of the type `T`.\n * @returns A function that, when called, will remove the event listener and close the EventSource.\n *\n * @example\n * const unsubscribe = on('testTopic', data => console.log(data)); // Sets up a listener on 'testTopic', and logs any received data.\n * unsubscribe(); // Closes the listener when no longer needed.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource EventSource API\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent MessageEvent\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n */\nexport const on = <T extends JsonValue | undefined>(\n\ttopic: string,\n\thandler: (data: T) => void,\n): (() => void) => {\n\tconst eventSource = new EventSource(`/topic/${encodeURIComponent(topic)}`);\n\n\tconst eventListener = (event: MessageEvent) => {\n\t\tconst data = JSON.parse(event.data) as T;\n\t\thandler(data);\n\t};\n\n\teventSource.addEventListener(topic, eventListener);\n\n\treturn () => {\n\t\teventSource.removeEventListener(topic, eventListener);\n\t\teventSource.close();\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { set } from \"./set\";\n\n/**\n * Returns a function that updates a specified key with a new value using the `set` function.\n *\n * The function that's returned will, when called, asynchronously update the value associated with the specified key. It uses the `set` function to perform the update.\n *\n * @typeParam T - The type of the value to be set. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param key - The key for which the value should be updated. It should be a string.\n * @returns - A function that takes a value of type `T` and returns a Promise that resolves to `void`. This function, when called, will asynchronously update the value associated with the specified key.\n *\n * @example\n * const setScore = useMutation<number>('score');\n *\n * await setScore(100); // Sets the value associated with the key 'score' to 100.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link set}\n */\nexport const useMutation = <T extends JsonValue | undefined>(\n\tkey: string,\n): ((value: T) => Promise<void>) => {\n\treturn async (value: T) => {\n\t\treturn await set(key, value);\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { get } from \"./get\";\n\n/**\n * Returns a function that fetches a value associated with a specified key using the `get` function.\n *\n * The function that's returned will, when called, asynchronously fetch the value associated with the specified key. It uses the `get` function to perform the fetch operation.\n *\n * @typeParam T - The type of the value to be fetched. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param key - The key for which the value should be fetched. It should be a string.\n * @param initialValue - An optional parameter, which is the initial value of type `T`. If the `get` function can't find a value associated with the key, it will return this initial value.\n * @returns - A function that returns a Promise that resolves to a value of type `T`. This function, when called, will asynchronously fetch the value associated with the specified key.\n *\n * @example\n * const getScore = useQuery<number>('score', 0);\n *\n * const score = await getScore(); // Fetches the value associated with the key 'score'. If not present, returns 0.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link get}\n */\nexport const useQuery = <T extends JsonValue | undefined>(\n\tkey: string,\n\tinitialValue?: T,\n): (() => Promise<T>) => {\n\treturn async () => {\n\t\treturn await get<T>(key, initialValue);\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { useMutation } from \"./use-mutation\";\nimport { useQuery } from \"./use-query\";\n\n/**\n * A custom hook that provides an interface to fetch and update a value associated with a specific key.\n *\n * `useKey` combines the capabilities of `useQuery` and `useMutation`, offering a unified approach to retrieve and modify data linked to a certain key.\n *\n * @param key - The key for which the value will be queried and potentially mutated. This key should be of type string.\n * @param initialValue - An optional parameter representing the default value of type `T`. If the `useQuery` function can't find a value associated with the key, this initial value is returned.\n *\n * @returns An object with two primary methods:\n *            1) `get`: A function that fetches the value linked to the specified key. This corresponds to the functionality provided by `useQuery`.\n *            2) `set`: A function that updates the value of the specified key. This mirrors the behavior of `useMutation`.\n *\n * @example\n * const scoreKey = useKey('score');\n *\n * const score = await scoreKey.get(); // Retrieves the value associated with the key 'score'.\n *\n * await scoreKey.set(100); // Updates the value associated with the key 'score' to 100.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link useQuery}\n * {@link useMutation}\n */\nexport const useKey = <T extends JsonValue | undefined>(\n\tkey: string,\n\tinitialValue?: T,\n) => {\n\tconst query = useQuery<T>(key, initialValue);\n\n\tconst mutate = useMutation<T>(key);\n\n\treturn {\n\t\tget: query,\n\t\tset: mutate,\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { emit } from \"./emit\";\n\n/**\n * Returns a function that publishes data to a specified topic using the `emit` function.\n *\n * The function that's returned will, when called with data, asynchronously publish that data to the specified topic.\n *\n * @typeParam T - The type of the data to be published. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param topic - The topic to which the data should be published. It should be a string.\n * @returns A function that takes data of type `T` and returns a Promise that resolves to `void`. This function, when called, will asynchronously publish the data to the specified topic.\n *\n * @example\n * const publishScore = usePublication<number>('score');\n *\n * await publishScore(100); // Publishes the value 100 to the topic 'score'.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link emit}\n */\nexport const usePublication = <T extends JsonValue | undefined>(\n\ttopic: string,\n): ((data: T) => Promise<void>) => {\n\treturn async (data: T) => {\n\t\treturn await emit(topic, data);\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { on } from \"./on\";\n\n/**\n * Returns a function that sets up a subscription to a specified topic using the `on` function.\n *\n * The function that's returned will, when called with a handler function, set up a subscription on the specified topic. The handler function is invoked whenever data associated with the topic is published. The subscription is removed when the returned cleanup function is called.\n *\n * @typeParam T - The type of the data to be handled. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param topic - The topic for which the subscription should be set. It should be a string.\n * @returns A function that takes a handler function of type `(data: T) => void` and returns a cleanup function of type `() => void`. The handler function is called whenever data is published on the topic. The cleanup function, when called, will remove the subscription.\n *\n * @example\n * const handleScoreUpdate = useSubscription<number>('score');\n *\n * const cleanup = handleScoreUpdate(score => {\n *   console.log(`Score updated: ${score}`);\n * });\n *\n * // Later...\n * cleanup(); // Removes the subscription to the 'score' topic.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link on}\n */\nexport const useSubscription = <T extends JsonValue | undefined>(\n\ttopic: string,\n): ((handler: (data: T) => void) => () => void) => {\n\treturn (handler: (data: T) => void) => {\n\t\treturn on(topic, handler);\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { usePublication } from \"./use-publication\";\nimport { useSubscription } from \"./use-subscription\";\n\n/**\n * Returns an object containing functions for subscribing to and publishing data on a specified topic.\n *\n * This function combines the functionality of `usePublication` and `useSubscription` into a single, convenient function.\n *\n * @typeParam T - The type of the data to be published or received from the topic. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param topic - The topic to be used for subscription and publication. It should be a string.\n * @returns - An object containing two functions:\n *            1) `on` which is equivalent to `useSubscription` for the specified topic.\n *            2) `emit` which is equivalent to `usePublication` for the specified topic.\n *\n * @example\n * const scoreTopic = useTopic<number>('score');\n *\n * const cleanup = scoreTopic.on(score => {\n *   console.log(`Score updated: ${score}`);\n * });\n *\n * await scoreTopic.emit(100); // Publishes the value 100 to the topic 'score'.\n *\n * // Later...\n * cleanup(); // Removes the subscription to the 'score' topic.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link usePublication}\n * {@link useSubscription}\n */\nexport const useTopic = <T extends JsonValue | undefined>(topic: string) => {\n\tconst publish = usePublication<T>(topic);\n\n\tconst subscribe = useSubscription<T>(topic);\n\n\treturn {\n\t\ton: subscribe,\n\t\temit: publish,\n\t};\n};\n", "import { JsonValue } from \"../../shared\";\nimport { useKey } from \"./use-key\";\nimport { useTopic } from \"./use-topic\";\n\n/**\n * Returns an object containing functions for managing state, including fetching the current state, updating it, and subscribing to state changes.\n *\n * This function leverages `useKey` for fetching and updating state and `useTopic` for subscribing to state changes.\n *\n * @typeParam T - The type of the state to be managed. It extends from `JsonValue | undefined`, which means it can be any JSON serializable value, or undefined.\n * @param key - The key to be used for querying and mutating the state. It should be a string.\n * @param initialValue - An optional parameter, which is the initial value of type `T`. If the `get` function can't find a value associated with the key, it will return this initial value.\n * @returns An object containing three functions:\n *            1) `get` which fetches the current state.\n *            2) `set` which updates the state and notifies subscribers.\n *            3) `onSet` which allows subscription to state changes.\n *\n * @example\n * const scoreState = useState<number>('score', 0);\n *\n * const currentScore = await scoreState.get(); // Fetches the current score. If not present, returns 0.\n *\n * await scoreState.set(100); // Sets the score to 100 and notifies subscribers.\n *\n * const cleanup = scoreState.onSet(newScore => {\n *   console.log(`Score updated: ${newScore}`);\n * });\n *\n * // Later...\n * cleanup(); // Removes the subscription.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link useKey}\n * {@link useTopic}\n */\nexport const useState = <T extends JsonValue | undefined>(\n\tkey: string,\n\tinitialValue?: T,\n) => {\n\tconst { get, set } = useKey<T>(key, initialValue);\n\n\tconst topic = window.crypto.randomUUID();\n\n\tconst { emit, on } = useTopic<T>(topic);\n\n\tconst setState = async (value: T) => {\n\t\tawait set(value);\n\n\t\tawait emit(value);\n\t};\n\n\treturn {\n\t\tget,\n\t\tset: setState,\n\t\tonSet: on,\n\t};\n};\n", "import { useState } from \"./use-state\";\n\n/**\n * Returns an object containing functions for managing a numeric counter state, including fetching the current state, updating it, incrementing, decrementing, and subscribing to state changes.\n *\n * This function leverages `useState` for fetching and updating state and adding `increment` and `decrement` functions.\n *\n * @param key - The key to be used for querying and mutating the state. It should be a string.\n * @param initialValue - The initial value to be used if the state is not present. It should be a number.\n * @returns An object containing six functions:\n *            1) `get` which fetches the current state.\n *            2) `set` which updates the state and notifies subscribers.\n *            3) `increment` which increases the current state by 1 and notifies subscribers.\n *            4) `decrement` which decreases the current state by 1 and notifies subscribers.\n *            5) `onSet` which allows subscription to state changes.\n *\n * @example\n * const counter = useCounter('count');\n *\n * const cleanup = counter.onSet(newCount => {\n *   console.log(`Count is now: ${newCount}`);\n * });\n *\n * const currentCount = await counter.get(); // Fetches the current count. If not present, returns 0.\n *\n * await counter.set(10); // Sets the count to 10 and notifies subscribers.\n *\n * await counter.increment(); // Increments the count (from 10 to 11) and notifies subscribers.\n *\n * await counter.decrement(); // Decrements the count (from 11 to 10) and notifies subscribers.\n *\n * // Later...\n * cleanup(); // Removes the subscription.\n *\n * @see https://developer.mozilla.org/en-US/docs/Glossary/JSON JSON\n * {@link useState}\n */\nexport const useCounter = (key: string, initialValue: number = 0) => {\n\tconst { get, set, onSet } = useState<number>(key, initialValue);\n\n\tconst increment = async () => {\n\t\tconst value = await get();\n\n\t\tawait set(value + 1);\n\t};\n\n\tconst decrement = async () => {\n\t\tconst value = await get();\n\n\t\tawait set(value - 1);\n\t};\n\n\treturn {\n\t\tget,\n\t\tset,\n\t\tonSet,\n\t\tincrement,\n\t\tdecrement,\n\t};\n};\n", "import { Frame } from \"../types\";\nimport { useCounter } from \"./use-counter\";\n\n/**\n * This hook initializes an animation frame loop, providing a means to subscribe to and unsubscribe from frame updates.\n *\n * It uses the `useCounter` hook to manage two counters, one for frame number and another for time. On each animation frame, it increments these counters\n * and notifies each subscribed handler with the current frame data.\n *\n * Additionally, you can specify handler functions to be invoked before and after each frame update.\n *\n * @param beforeFrameHandlers - A handler function to be invoked before each frame update. The handler receives the current frame of type `Frame` as its argument.\n * @param afterFrameHandlers - A handler function to be invoked after each frame update. The handler receives the current frame of type `Frame` as its argument.\n * @returns - A function that takes a handler of type `(frame: Frame) => Promise<void>`. This function will subscribe the handler to frame updates and returns a cleanup function. When the cleanup function is called, it unsubscribes the handler from frame updates.\n *\n * @example\n * const subscribe = useFrames(\n *    async frame => console.log('Before frame:', frame),\n *    async frame => console.log('After frame:', frame)\n * );\n *\n * const unsubscribe = subscribe(async frame => console.log('Frame:', frame)); // Logs the frame data to the console on each frame.\n * unsubscribe(); // Stops logging the frame data to the console.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame\n * @see Frame\n * @see useCounter\n */\nexport const useFrames = (\n\tbeforeFrameHandlers: (frame: Frame) => Promise<void>,\n\tafterFrameHandlers: (frame: Frame) => Promise<void>,\n) => {\n\tconst { get: getFrameNumber, set: setFrameNumber } =\n\t\tuseCounter(\"frameNumber\");\n\n\tconst { get: getTime, set: setTime } = useCounter(\"time\");\n\n\tconst frameHandlers: ((frame: Frame) => Promise<void>)[] = [];\n\n\tconst update = async () => {\n\t\tconst frameNumberPromise = getFrameNumber();\n\n\t\tconst timePromise = getTime();\n\n\t\tconst [previousFrameNumber, previousFrameTimestamp] = await Promise.all([\n\t\t\tframeNumberPromise,\n\t\t\ttimePromise,\n\t\t]);\n\n\t\tconst timestamp = Date.now();\n\n\t\tconst millisecondsSinceLastFrame = timestamp - previousFrameTimestamp;\n\n\t\tconst index = previousFrameNumber + 1;\n\n\t\tconst frame: Frame = {\n\t\t\tindex,\n\t\t\ttimestamp,\n\t\t\tmillisecondsSinceLastFrame,\n\t\t};\n\n\t\tawait Promise.all([setTime(timestamp), setFrameNumber(index)]);\n\n\t\tawait beforeFrameHandlers(frame);\n\n\t\tawait Promise.all([...frameHandlers].map((handler) => handler(frame)));\n\n\t\tawait afterFrameHandlers(frame);\n\n\t\trequestAnimationFrame(update);\n\t};\n\n\trequestAnimationFrame(update);\n\n\treturn (handler: (frame: Frame) => Promise<void>) => {\n\t\tframeHandlers.push(handler);\n\n\t\treturn () => {\n\t\t\tconst index = frameHandlers.indexOf(handler);\n\n\t\t\tframeHandlers.splice(index, 1);\n\t\t};\n\t};\n};\n", "import { useFrames } from \"./functions\";\n\nconst useFrame = useFrames(\n\tasync () => {\n\t\tconsole.log(\"before\");\n\t},\n\tasync () => {\n\t\tconsole.log(\"after\");\n\t},\n);\n\nuseFrame(async (frame) => {\n\tconsole.log(frame);\n});\n"],
  "mappings": "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",
  "names": ["get", "key", "initialValue", "response", "value", "set", "key", "value", "response", "emit", "topic", "data", "response", "on", "topic", "handler", "eventSource", "eventListener", "event", "data", "useMutation", "key", "value", "set", "useQuery", "key", "initialValue", "get", "useKey", "key", "initialValue", "query", "useQuery", "mutate", "useMutation", "usePublication", "topic", "data", "emit", "useSubscription", "topic", "handler", "on", "useTopic", "topic", "publish", "usePublication", "useSubscription", "useState", "key", "initialValue", "get", "set", "useKey", "topic", "emit", "on", "useTopic", "value", "useCounter", "key", "initialValue", "get", "set", "onSet", "useState", "value", "useFrames", "beforeFrameHandlers", "afterFrameHandlers", "getFrameNumber", "setFrameNumber", "useCounter", "getTime", "setTime", "frameHandlers", "update", "frameNumberPromise", "timePromise", "previousFrameNumber", "previousFrameTimestamp", "timestamp", "millisecondsSinceLastFrame", "index", "frame", "handler", "useFrame", "useFrames", "frame"]
}
